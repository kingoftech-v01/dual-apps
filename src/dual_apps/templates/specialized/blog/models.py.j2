"""
Blog Models for {{ project_name }}.
Generated by dual-apps v{{ version }} - Blog Template

Complete blog system with posts, categories, tags, and comments.
"""

import uuid
from django.db import models
from django.conf import settings
from django.utils.text import slugify
from django.utils import timezone


class BaseModel(models.Model):
    """Abstract base model."""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


class Category(BaseModel):
    """Blog category."""
    name = models.CharField(max_length=100)
    slug = models.SlugField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    image = models.ImageField(upload_to="blog/categories/", blank=True, null=True)
    parent = models.ForeignKey(
        "self", on_delete=models.CASCADE,
        null=True, blank=True, related_name="children"
    )
    is_active = models.BooleanField(default=True)
    order = models.PositiveIntegerField(default=0)

    class Meta:
        verbose_name_plural = "categories"
        ordering = ["order", "name"]

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    @property
    def post_count(self):
        return self.posts.filter(status="published").count()


class Tag(BaseModel):
    """Blog tag."""
    name = models.CharField(max_length=50, unique=True)
    slug = models.SlugField(max_length=50, unique=True)

    class Meta:
        ordering = ["name"]

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)


class Post(BaseModel):
    """Blog post."""
    STATUS_CHOICES = [
        ("draft", "Draft"),
        ("published", "Published"),
        ("scheduled", "Scheduled"),
        ("archived", "Archived"),
    ]

    # Basic
    title = models.CharField(max_length=255)
    slug = models.SlugField(max_length=255, unique=True)
    excerpt = models.TextField(max_length=500, blank=True)
    content = models.TextField()

    # Media
    featured_image = models.ImageField(upload_to="blog/posts/", blank=True, null=True)
    featured_image_alt = models.CharField(max_length=200, blank=True)

    # Organization
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="blog_posts"
    )
    category = models.ForeignKey(
        Category, on_delete=models.SET_NULL,
        null=True, related_name="posts"
    )
    tags = models.ManyToManyField(Tag, blank=True, related_name="posts")

    # Publishing
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="draft")
    published_at = models.DateTimeField(null=True, blank=True)

    # Options
    allow_comments = models.BooleanField(default=True)
    is_featured = models.BooleanField(default=False)
    is_pinned = models.BooleanField(default=False)

    # SEO
    meta_title = models.CharField(max_length=70, blank=True)
    meta_description = models.CharField(max_length=160, blank=True)

    # Stats
    view_count = models.PositiveIntegerField(default=0)

    # Reading time (auto-calculated)
    reading_time = models.PositiveIntegerField(default=0)  # minutes

    class Meta:
        ordering = ["-is_pinned", "-published_at"]
        indexes = [
            models.Index(fields=["slug"]),
            models.Index(fields=["status", "published_at"]),
        ]

    def __str__(self):
        return self.title

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)

        # Auto-publish date
        if self.status == "published" and not self.published_at:
            self.published_at = timezone.now()

        # Calculate reading time (avg 200 words per minute)
        word_count = len(self.content.split())
        self.reading_time = max(1, word_count // 200)

        super().save(*args, **kwargs)

    @property
    def is_published(self):
        return self.status == "published" and self.published_at <= timezone.now()

    @property
    def comment_count(self):
        return self.comments.filter(is_approved=True).count()


class Comment(BaseModel):
    """Post comment with nested replies."""
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name="comments")
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        null=True, blank=True,
        related_name="blog_comments"
    )

    # Guest comments
    author_name = models.CharField(max_length=100, blank=True)
    author_email = models.EmailField(blank=True)
    author_website = models.URLField(blank=True)

    content = models.TextField()
    parent = models.ForeignKey(
        "self", on_delete=models.CASCADE,
        null=True, blank=True, related_name="replies"
    )

    is_approved = models.BooleanField(default=False)
    is_spam = models.BooleanField(default=False)

    class Meta:
        ordering = ["created_at"]

    def __str__(self):
        return f"Comment by {self.get_author_name()} on {self.post.title}"

    def get_author_name(self):
        if self.author:
            return self.author.get_full_name() or self.author.username
        return self.author_name or "Anonymous"


class NewsletterSubscriber(BaseModel):
    """Newsletter subscription."""
    email = models.EmailField(unique=True)
    is_active = models.BooleanField(default=True)
    confirmed_at = models.DateTimeField(null=True, blank=True)
    unsubscribed_at = models.DateTimeField(null=True, blank=True)

    def __str__(self):
        return self.email


class PostLike(BaseModel):
    """Post likes/reactions."""
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name="likes")
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="post_likes"
    )

    class Meta:
        unique_together = ["post", "user"]

    def __str__(self):
        return f"{self.user} likes {self.post.title}"

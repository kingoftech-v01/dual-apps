"""
Custom middleware for {{ project_name }}.
Generated by dual-apps v{{ version }}

Security and utility middleware.
"""

import time
import logging
from django.conf import settings
from django.http import JsonResponse
from django.core.cache import cache

logger = logging.getLogger(__name__)


class SecurityHeadersMiddleware:
    """
    Add security headers to all responses.

    Headers added:
    - X-Content-Type-Options: nosniff
    - X-Frame-Options: DENY
    - X-XSS-Protection: 1; mode=block
    - Referrer-Policy: strict-origin-when-cross-origin
    - Permissions-Policy: geolocation=(), microphone=(), camera=()
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)

        # Security headers
        response["X-Content-Type-Options"] = "nosniff"
        response["X-Frame-Options"] = "DENY"
        response["X-XSS-Protection"] = "1; mode=block"
        response["Referrer-Policy"] = "strict-origin-when-cross-origin"
        response["Permissions-Policy"] = "geolocation=(), microphone=(), camera=()"

        # Remove server header
        if "Server" in response:
            del response["Server"]

        return response


class RateLimitMiddleware:
    """
    Simple rate limiting middleware.

    Limits requests per IP address.

    Settings:
        RATE_LIMIT_REQUESTS: Max requests (default: 100)
        RATE_LIMIT_WINDOW: Time window in seconds (default: 60)
    """

    def __init__(self, get_response):
        self.get_response = get_response
        self.max_requests = getattr(settings, 'RATE_LIMIT_REQUESTS', 100)
        self.window = getattr(settings, 'RATE_LIMIT_WINDOW', 60)

    def __call__(self, request):
        # Get client IP
        ip = self.get_client_ip(request)
        cache_key = f"ratelimit:{ip}"

        # Get current count
        request_count = cache.get(cache_key, 0)

        if request_count >= self.max_requests:
            return JsonResponse(
                {
                    "error": "Rate limit exceeded",
                    "message": f"Maximum {self.max_requests} requests per {self.window} seconds",
                    "retry_after": self.window,
                },
                status=429
            )

        # Increment count
        cache.set(cache_key, request_count + 1, self.window)

        response = self.get_response(request)

        # Add rate limit headers
        response["X-RateLimit-Limit"] = str(self.max_requests)
        response["X-RateLimit-Remaining"] = str(self.max_requests - request_count - 1)

        return response

    def get_client_ip(self, request):
        """Get client IP from request."""
        x_forwarded_for = request.META.get("HTTP_X_FORWARDED_FOR")
        if x_forwarded_for:
            return x_forwarded_for.split(",")[0].strip()
        return request.META.get("REMOTE_ADDR", "unknown")


class RequestLoggingMiddleware:
    """
    Log all requests for debugging and monitoring.

    Logs: method, path, status, duration, user.
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        start_time = time.time()

        response = self.get_response(request)

        duration = time.time() - start_time
        user = request.user.email if request.user.is_authenticated else "anonymous"

        logger.info(
            f"{request.method} {request.path} "
            f"status={response.status_code} "
            f"duration={duration:.3f}s "
            f"user={user}"
        )

        return response


class APIVersionMiddleware:
    """
    Handle API versioning via header or URL.

    Supports:
    - Header: Accept: application/vnd.{{ project_name }}.v1+json
    - URL: /api/v1/...
    """

    def __init__(self, get_response):
        self.get_response = get_response
        self.default_version = "v1"

    def __call__(self, request):
        # Check Accept header
        accept = request.META.get("HTTP_ACCEPT", "")
        if "vnd.{{ project_name }}." in accept:
            # Extract version from header
            import re
            match = re.search(r"vnd\.{{ project_name }}\.v(\d+)", accept)
            if match:
                request.api_version = f"v{match.group(1)}"
        else:
            # Extract from URL
            if request.path.startswith("/api/v"):
                version = request.path.split("/")[2]
                request.api_version = version
            else:
                request.api_version = self.default_version

        return self.get_response(request)


class MaintenanceModeMiddleware:
    """
    Enable maintenance mode via settings.

    Settings:
        MAINTENANCE_MODE: bool (default: False)
        MAINTENANCE_BYPASS_IPS: list of IPs to bypass
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        if getattr(settings, 'MAINTENANCE_MODE', False):
            bypass_ips = getattr(settings, 'MAINTENANCE_BYPASS_IPS', [])
            client_ip = self.get_client_ip(request)

            if client_ip not in bypass_ips:
                return JsonResponse(
                    {
                        "error": "Service Unavailable",
                        "message": "The service is currently under maintenance. Please try again later.",
                    },
                    status=503
                )

        return self.get_response(request)

    def get_client_ip(self, request):
        x_forwarded_for = request.META.get("HTTP_X_FORWARDED_FOR")
        if x_forwarded_for:
            return x_forwarded_for.split(",")[0].strip()
        return request.META.get("REMOTE_ADDR", "unknown")

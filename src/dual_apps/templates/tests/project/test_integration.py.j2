"""
Integration tests for {{ project_name }}.
Generated by dual-apps v{{ version }}

Tests cross-app functionality and system-wide behavior.
"""

import pytest
from django.urls import reverse
from django.contrib.auth import get_user_model

User = get_user_model()


class TestProjectSetup:
    """Test project is correctly configured."""

    def test_settings_loaded(self):
        """Test Django settings are loaded."""
        from django.conf import settings
        assert settings.ROOT_URLCONF == "{{ project_name }}.urls"

    def test_apps_installed(self):
        """Test all apps are installed."""
        from django.conf import settings
        {% for app in apps %}
        assert "apps.{{ app }}" in settings.INSTALLED_APPS
        {% endfor %}

    def test_database_connection(self, db):
        """Test database is accessible."""
        user_count = User.objects.count()
        assert user_count >= 0


class TestAuthentication:
    """Test authentication flows."""

    def test_admin_login_page(self, client):
        """Test admin login page is accessible."""
        response = client.get("/admin/login/")
        assert response.status_code == 200

    def test_user_login(self, client, user):
        """Test user can log in."""
        response = client.post("/admin/login/", {
            "username": "testuser",
            "password": "testpass123",
        }, follow=True)
        assert response.status_code == 200

    def test_invalid_login(self, client):
        """Test invalid login is rejected."""
        response = client.post("/admin/login/", {
            "username": "invalid",
            "password": "invalid",
        })
        assert response.status_code == 200  # Returns to login page
        assert b"Please enter the correct" in response.content or b"error" in response.content.lower()

{% if use_allauth %}

class TestAllauthAuthentication:
    """Test django-allauth authentication flows."""

    def test_allauth_login_page(self, client):
        """Test allauth login page is accessible."""
        response = client.get("/accounts/login/")
        assert response.status_code == 200

    def test_allauth_signup_page(self, client):
        """Test allauth signup page is accessible."""
        response = client.get("/accounts/signup/")
        assert response.status_code == 200

    def test_allauth_logout(self, auth_client):
        """Test allauth logout works."""
        response = auth_client.post("/accounts/logout/", follow=True)
        assert response.status_code == 200
{% endif %}


class TestAPIRoot:
    """Test API root endpoints."""

    def test_api_root(self, api_client):
        """Test API root is accessible."""
        response = api_client.get("/api/v1/")
        assert response.status_code == 200

    def test_api_authentication_required_for_write(self, api_client):
        """Test API requires authentication for write operations."""
        {% for app in apps %}
        response = api_client.post("/api/v1/{{ app }}/", {"title": "Test"})
        assert response.status_code in [401, 403]
        {% endfor %}


{% for app in apps_config %}
class Test{{ app.name_pascal }}Integration:
    """Integration tests for {{ app.name_title }}."""

    def test_frontend_list_view(self, auth_client):
        """Test frontend list view."""
        response = auth_client.get("/{{ app.name }}/")
        assert response.status_code == 200

    def test_api_list_endpoint(self, api_client):
        """Test API list endpoint."""
        response = api_client.get("/api/v1/{{ app.name }}/")
        assert response.status_code == 200
        assert "results" in response.json() or isinstance(response.json(), list)

    def test_create_via_api(self, auth_api_client, {{ app.name }}_data):
        """Test creating via API."""
        response = auth_api_client.post("/api/v1/{{ app.name }}/", {{ app.name }}_data)
        assert response.status_code == 201
        assert response.json()["title"] == {{ app.name }}_data["title"]

    def test_owner_can_update(self, auth_api_client, {{ app.name }}_instance):
        """Test owner can update their own item."""
        instance = {{ app.name }}_instance
        response = auth_api_client.patch(
            f"/api/v1/{{ app.name }}/{instance.id}/",
            {"title": "Updated Title"}
        )
        assert response.status_code == 200
        assert response.json()["title"] == "Updated Title"

    def test_non_owner_cannot_update(self, api_client, {{ app.name }}_instance, db):
        """Test non-owner cannot update."""
        instance = {{ app.name }}_instance
        other_user = User.objects.create_user(
            username="other",
            password="otherpass123"
        )
        api_client.force_authenticate(user=other_user)
        response = api_client.patch(
            f"/api/v1/{{ app.name }}/{instance.id}/",
            {"title": "Hacked"}
        )
        assert response.status_code == 403

{% endfor %}

class TestCrossAppFunctionality:
    """Test functionality across multiple apps."""

    def test_user_can_access_all_apps(self, auth_client):
        """Test authenticated user can access all apps."""
        {% for app in apps %}
        response = auth_client.get("/{{ app }}/")
        assert response.status_code == 200
        {% endfor %}

    def test_api_consistent_pagination(self, api_client):
        """Test API pagination is consistent across apps."""
        {% for app in apps %}
        response = api_client.get("/api/v1/{{ app }}/")
        data = response.json()
        # Check pagination structure (if paginated)
        if "results" in data:
            assert "count" in data
        {% endfor %}


class TestSecurityHeaders:
    """Test security headers are set correctly."""

    def test_csrf_cookie_set(self, client):
        """Test CSRF cookie is set."""
        response = client.get("/admin/login/")
        assert "csrftoken" in response.cookies

    def test_content_type_header(self, api_client):
        """Test content type header is set."""
        response = api_client.get("/api/v1/")
        assert "application/json" in response["Content-Type"]

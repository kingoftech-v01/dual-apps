"""
DRF Serializers for {{ app_name }} app.

Following DRF best practices:
- Multiple serializers per model (list, detail, create)
- Nested serializers for related objects
- Validation methods
- Read-only computed fields

Generated by dual-apps v{{ version }}
"""

from rest_framework import serializers
from django.contrib.auth import get_user_model

from {{ app_name }}.models import {{ model_name }}


User = get_user_model()


class OwnerSerializer(serializers.ModelSerializer):
    """Lightweight serializer for owner field."""

    class Meta:
        model = User
        fields = ['id', 'username']
        read_only_fields = fields


class {{ model_name }}ListSerializer(serializers.ModelSerializer):
    """
    Lightweight serializer for list views.

    Optimized for performance - minimal fields.
    Used in: GET /api/v1/{{ app_name }}/{{ model_name_kebab }}s/
    """

    owner = OwnerSerializer(read_only=True)
    url = serializers.HyperlinkedIdentityField(
        view_name='api:v1:{{ app_name }}:{{ model_name_snake }}-detail'
    )

    class Meta:
        model = {{ model_name }}
        fields = [
            'id',
            'url',
            'title',
            'status',
            'owner',
            'created_at',
        ]
        read_only_fields = fields


class {{ model_name }}Serializer(serializers.ModelSerializer):
    """
    Full serializer for detail views.

    Includes all fields and nested relationships.
    Used in: GET /api/v1/{{ app_name }}/{{ model_name_kebab }}s/{id}/
    """

    owner = OwnerSerializer(read_only=True)
    is_owner = serializers.SerializerMethodField()
    url = serializers.HyperlinkedIdentityField(
        view_name='api:v1:{{ app_name }}:{{ model_name_snake }}-detail'
    )

    class Meta:
        model = {{ model_name }}
        fields = [
            'id',
            'url',
            {% for field_name, field_type, options in fields %}
            '{{ field_name }}',
            {% endfor %}
            'owner',
            'is_owner',
            'created_at',
            'updated_at',
        ]
        read_only_fields = ['id', 'owner', 'is_owner', 'created_at', 'updated_at']

    def get_is_owner(self, obj) -> bool:
        """Check if current user is the owner."""
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            return obj.owner == request.user
        return False


class {{ model_name }}CreateSerializer(serializers.ModelSerializer):
    """
    Serializer for create/update operations.

    Focused on validation.
    Used in: POST /api/v1/{{ app_name }}/{{ model_name_kebab }}s/
    """

    class Meta:
        model = {{ model_name }}
        fields = [
            {% for field_name, field_type, options in fields %}
            '{{ field_name }}',
            {% endfor %}
        ]

    def validate_title(self, value: str) -> str:
        """Validate title field."""
        if len(value) < 3:
            raise serializers.ValidationError(
                "Title must be at least 3 characters long."
            )
        return value.strip()

    def validate(self, attrs: dict) -> dict:
        """Cross-field validation."""
        # Add custom validation logic here
        return attrs

    def create(self, validated_data: dict) -> {{ model_name }}:
        """Create new {{ model_name }}."""
        # Owner is set in ViewSet.perform_create()
        return super().create(validated_data)


class {{ model_name }}BulkSerializer(serializers.Serializer):
    """
    Serializer for bulk operations.

    Used for bulk archive, delete, etc.
    """

    ids = serializers.ListField(
        child=serializers.UUIDField(),
        min_length=1,
        max_length=100,
        help_text="List of {{ model_name }} IDs"
    )
    action = serializers.ChoiceField(
        choices=['archive', 'delete', 'publish'],
        help_text="Action to perform"
    )

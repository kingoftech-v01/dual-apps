"""
DRF Permission classes for {{ app_name }} app.

Permission hierarchy:
1. Anonymous: Public read-only
2. Authenticated: Own resources + public
3. Owner: Full CRUD on own resources
4. Staff: Admin access to all

Generated by dual-apps v{{ version }}
"""

from rest_framework.permissions import BasePermission, SAFE_METHODS


class IsOwnerOrReadOnly(BasePermission):
    """
    Object-level permission: Owner can edit, others read-only.

    - Safe methods (GET, HEAD, OPTIONS): Allow all
    - Unsafe methods (POST, PUT, DELETE): Owner or staff only

    Usage:
        permission_classes = [IsOwnerOrReadOnly]
    """

    def has_object_permission(self, request, view, obj):
        """Check object-level permission."""
        # Read permissions for any request
        if request.method in SAFE_METHODS:
            return True

        # Write permissions only for owner or staff
        return obj.owner == request.user or request.user.is_staff


class IsOwner(BasePermission):
    """
    Object-level permission: Only owner can access.

    Strict ownership check for all methods.

    Usage:
        permission_classes = [IsAuthenticated, IsOwner]
    """

    def has_object_permission(self, request, view, obj):
        """Only owner can access."""
        return obj.owner == request.user


class IsStaffOrReadOnly(BasePermission):
    """
    Staff can edit, others read-only.

    Usage:
        permission_classes = [IsStaffOrReadOnly]
    """

    def has_permission(self, request, view):
        """Check view-level permission."""
        if request.method in SAFE_METHODS:
            return True
        return request.user and request.user.is_staff


class IsActiveOrStaff(BasePermission):
    """
    Only allow access to active objects (or staff).

    Filters out soft-deleted objects for non-staff.

    Usage:
        permission_classes = [IsActiveOrStaff]
    """

    def has_object_permission(self, request, view, obj):
        """Check if object is active or user is staff."""
        if request.user and request.user.is_staff:
            return True
        return getattr(obj, 'is_active', True)


class DualPermissions:
    """
    Standardized permission constants for dual-apps.

    Usage:
        from {{ app_name }}.permissions import DualPermissions

        if user.has_perm(DualPermissions.ADD.format(model='{{ model_name_snake }}')):
            ...
    """

    # CRUD standard
    ADD = 'add_{model}'
    CHANGE = 'change_{model}'
    DELETE = 'delete_{model}'
    VIEW = 'view_{model}'

    # Custom (dual-apps convention)
    ARCHIVE = 'archive_{model}'
    PUBLISH = 'publish_{model}'
    BULK_EDIT = 'bulk_edit_{model}'


class CanArchive(BasePermission):
    """
    Permission to archive objects.

    Requires:
    - Authentication
    - Owner or staff
    - Object not already archived

    Usage:
        @action(detail=True, permission_classes=[CanArchive])
        def archive(self, request, pk=None):
            ...
    """

    def has_object_permission(self, request, view, obj):
        """Check archive permission."""
        if not request.user.is_authenticated:
            return False

        # Already archived
        if getattr(obj, 'status', None) == 'archived':
            return False

        # Owner or staff
        return obj.owner == request.user or request.user.is_staff


class CanPublish(BasePermission):
    """
    Permission to publish objects.

    Requires:
    - Authentication
    - Owner or staff
    - Object in draft status

    Usage:
        @action(detail=True, permission_classes=[CanPublish])
        def publish(self, request, pk=None):
            ...
    """

    def has_object_permission(self, request, view, obj):
        """Check publish permission."""
        if not request.user.is_authenticated:
            return False

        # Only draft can be published
        if getattr(obj, 'status', None) != 'draft':
            return False

        # Owner or staff
        return obj.owner == request.user or request.user.is_staff

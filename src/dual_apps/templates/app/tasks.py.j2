"""
Celery tasks for {{ app_name }} app.

Async task definitions using Celery for background processing.

Generated by dual-apps v{{ version }}
"""

from celery import shared_task
from django.utils import timezone
import logging

logger = logging.getLogger(__name__)


@shared_task(bind=True, max_retries=3)
def process_{{ model_name_snake }}(self, {{ model_name_snake }}_id: str) -> dict:
    """
    Process a {{ model_name }} asynchronously.

    Args:
        {{ model_name_snake }}_id: UUID of the {{ model_name }} to process

    Returns:
        dict: Processing result with status and message
    """
    from {{ app_full_name | default(app_name) }}.models import {{ model_name }}

    try:
        instance = {{ model_name }}.objects.get(id={{ model_name_snake }}_id)
        logger.info(f"Processing {{ model_name }} {instance.id}")

        # Add your processing logic here
        # Example: Update status, send notifications, etc.

        instance.updated_at = timezone.now()
        instance.save(update_fields=['updated_at'])

        return {
            "status": "success",
            "message": f"{{ model_name }} {instance.id} processed successfully",
            "id": str(instance.id),
        }

    except {{ model_name }}.DoesNotExist:
        logger.error(f"{{ model_name }} {{"{"}}{{ model_name_snake }}_id} not found")
        return {
            "status": "error",
            "message": f"{{ model_name }} not found",
            "id": {{ model_name_snake }}_id,
        }

    except Exception as exc:
        logger.exception(f"Error processing {{ model_name }}: {exc}")
        # Retry with exponential backoff
        raise self.retry(exc=exc, countdown=2 ** self.request.retries)


@shared_task
def cleanup_old_{{ model_name_snake }}s(days: int = 30) -> dict:
    """
    Clean up old archived {{ model_name }} records.

    Args:
        days: Number of days after which to clean up archived records

    Returns:
        dict: Cleanup result with count of deleted records
    """
    from {{ app_full_name | default(app_name) }}.models import {{ model_name }}
    from datetime import timedelta

    cutoff_date = timezone.now() - timedelta(days=days)

    deleted_count, _ = {{ model_name }}.objects.filter(
        status='archived',
        updated_at__lt=cutoff_date
    ).delete()

    logger.info(f"Cleaned up {deleted_count} old {{ model_name }} records")

    return {
        "status": "success",
        "deleted_count": deleted_count,
        "cutoff_date": cutoff_date.isoformat(),
    }


@shared_task
def send_{{ model_name_snake }}_notification(
    {{ model_name_snake }}_id: str,
    notification_type: str = "update"
) -> dict:
    """
    Send notification for a {{ model_name }}.

    Args:
        {{ model_name_snake }}_id: UUID of the {{ model_name }}
        notification_type: Type of notification (create, update, delete)

    Returns:
        dict: Notification result
    """
    from {{ app_full_name | default(app_name) }}.models import {{ model_name }}

    try:
        instance = {{ model_name }}.objects.get(id={{ model_name_snake }}_id)

        # Add your notification logic here
        # Example: Send email, push notification, webhook, etc.

        logger.info(
            f"Sent {notification_type} notification for {{ model_name }} {instance.id}"
        )

        return {
            "status": "success",
            "notification_type": notification_type,
            "id": str(instance.id),
        }

    except {{ model_name }}.DoesNotExist:
        logger.error(f"{{ model_name }} {{"{"}}{{ model_name_snake }}_id} not found for notification")
        return {
            "status": "error",
            "message": "{{ model_name }} not found",
        }

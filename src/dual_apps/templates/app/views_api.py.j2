"""
REST API ViewSet for {{ app_name }} app.

Following DRF best practices:
- ModelViewSet for complete CRUD
- Filtering, search, ordering
- Custom actions (archive, publish)
- Permission classes

Generated by dual-apps v{{ version }}

API Endpoints:
    GET    /api/v1/{{ app_name }}/{{ model_name_kebab }}s/          List all
    POST   /api/v1/{{ app_name }}/{{ model_name_kebab }}s/          Create new
    GET    /api/v1/{{ app_name }}/{{ model_name_kebab }}s/{id}/     Retrieve one
    PUT    /api/v1/{{ app_name }}/{{ model_name_kebab }}s/{id}/     Update
    DELETE /api/v1/{{ app_name }}/{{ model_name_kebab }}s/{id}/     Delete
    POST   /api/v1/{{ app_name }}/{{ model_name_kebab }}s/{id}/archive/  Archive
"""

from rest_framework import viewsets, status, filters
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, IsAuthenticatedOrReadOnly
from django_filters.rest_framework import DjangoFilterBackend

from {{ app_name }}.models import {{ model_name }}
from {{ app_name }}.serializers import (
    {{ model_name }}Serializer,
    {{ model_name }}ListSerializer,
    {{ model_name }}CreateSerializer,
)
from {{ app_name }}.permissions import IsOwnerOrReadOnly


class {{ model_name }}ViewSet(viewsets.ModelViewSet):
    """
    Complete CRUD API for {{ model_name }}.

    Features:
    - List with filtering, search, ordering
    - Create with automatic owner assignment
    - Update/Delete with owner permission
    - Custom actions (archive, publish, duplicate)

    Permissions:
    - List/Retrieve: Public (read-only) or authenticated
    - Create: Authenticated required
    - Update/Delete: Owner or staff only

    Filtering:
        ?status=active          Filter by status
        ?search=keyword         Search in title, description
        ?ordering=-created_at   Order by field

    Pagination:
        Default: 20 items per page
        ?page=2                 Page number
        ?page_size=50           Items per page (max 100)
    """

    queryset = {{ model_name }}.objects.select_related('owner').filter(is_active=True)
    serializer_class = {{ model_name }}Serializer
    {% if auth_required %}
    permission_classes = [IsAuthenticated, IsOwnerOrReadOnly]
    {% else %}
    permission_classes = [IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly]
    {% endif %}

    # Filtering backends
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ['status', 'is_active', 'owner']
    search_fields = ['title', 'description']
    ordering_fields = ['created_at', 'updated_at', 'title']
    ordering = ['-created_at']

    def get_serializer_class(self):
        """
        Return appropriate serializer based on action.

        - list: Lightweight serializer
        - create: Validation-focused serializer
        - others: Full serializer
        """
        if self.action == 'list':
            return {{ model_name }}ListSerializer
        elif self.action == 'create':
            return {{ model_name }}CreateSerializer
        return {{ model_name }}Serializer

    def get_queryset(self):
        """
        Filter queryset based on user permissions.

        - Staff: All objects
        - Authenticated: Own objects + public
        - Anonymous: Public only
        """
        user = self.request.user
        queryset = super().get_queryset()

        if user.is_staff:
            return queryset
        elif user.is_authenticated:
            # Own objects + public active objects
            return queryset.filter(
                models.Q(owner=user) | models.Q(status='active')
            ).distinct()
        else:
            # Public only
            return queryset.filter(status='active')

    def perform_create(self, serializer):
        """
        Automatically assign owner on create.

        The owner is set to the authenticated user.
        """
        serializer.save(owner=self.request.user)

    @action(detail=True, methods=['post'])
    def archive(self, request, pk=None):
        """
        Archive a {{ model_name }}.

        POST /api/v1/{{ app_name }}/{{ model_name_kebab }}s/{id}/archive/

        Sets status to 'archived' and is_active to False.
        Only owner or staff can archive.
        """
        obj = self.get_object()
        obj.status = 'archived'
        obj.is_active = False
        obj.save(update_fields=['status', 'is_active', 'updated_at'])
        return Response(
            {'status': 'archived', 'id': str(obj.id)},
            status=status.HTTP_200_OK
        )

    @action(detail=True, methods=['post'])
    def publish(self, request, pk=None):
        """
        Publish a {{ model_name }}.

        POST /api/v1/{{ app_name }}/{{ model_name_kebab }}s/{id}/publish/

        Sets status to 'active'.
        Only owner or staff can publish.
        """
        obj = self.get_object()
        obj.status = 'active'
        obj.save(update_fields=['status', 'updated_at'])
        return Response(
            {'status': 'published', 'id': str(obj.id)},
            status=status.HTTP_200_OK
        )

    @action(detail=True, methods=['post'])
    def duplicate(self, request, pk=None):
        """
        Duplicate a {{ model_name }}.

        POST /api/v1/{{ app_name }}/{{ model_name_kebab }}s/{id}/duplicate/

        Creates a copy with new UUID and 'draft' status.
        Owner is set to current user.
        """
        obj = self.get_object()
        obj.pk = None  # Creates new object
        obj.id = None
        obj.status = 'draft'
        obj.owner = request.user
        obj.save()
        serializer = self.get_serializer(obj)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    @action(detail=False, methods=['get'])
    def my_items(self, request):
        """
        Get current user's {{ model_name }}s.

        GET /api/v1/{{ app_name }}/{{ model_name_kebab }}s/my_items/

        Returns only objects owned by authenticated user.
        """
        queryset = self.get_queryset().filter(owner=request.user)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


# Import models for Q objects
from django.db import models

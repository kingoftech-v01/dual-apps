"""
REST API ViewSet for {{ app_name }} app.

Following DRF best practices:
- ModelViewSet for complete CRUD
- Filtering, search, ordering
- Custom actions (archive, publish)
- Permission classes
- OpenAPI documentation (drf-spectacular)

Generated by dual-apps v{{ version }}

API Endpoints:
    GET    /api/v1/{{ app_name }}/          List all
    POST   /api/v1/{{ app_name }}/          Create new
    GET    /api/v1/{{ app_name }}/{id}/     Retrieve one
    PUT    /api/v1/{{ app_name }}/{id}/     Update
    DELETE /api/v1/{{ app_name }}/{id}/     Delete
    POST   /api/v1/{{ app_name }}/{id}/archive/  Archive
"""

from django.db import models
from rest_framework import viewsets, status, filters
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, IsAuthenticatedOrReadOnly
from django_filters.rest_framework import DjangoFilterBackend
from drf_spectacular.utils import (
    extend_schema,
    extend_schema_view,
    OpenApiParameter,
    OpenApiResponse,
    OpenApiExample,
)
from drf_spectacular.types import OpenApiTypes

from .models import {{ model_name }}
from .serializers import (
    {{ model_name }}Serializer,
    {{ model_name }}ListSerializer,
    {{ model_name }}CreateSerializer,
)
from .permissions import IsOwnerOrReadOnly


@extend_schema_view(
    list=extend_schema(
        summary="List {{ model_name_title }}s",
        description="Retrieve a paginated list of {{ model_name_title }}s with filtering options.",
        parameters=[
            OpenApiParameter(
                name="status",
                type=OpenApiTypes.STR,
                description="Filter by status (draft, active, archived)",
            ),
            OpenApiParameter(
                name="search",
                type=OpenApiTypes.STR,
                description="Search in title and description",
            ),
            OpenApiParameter(
                name="ordering",
                type=OpenApiTypes.STR,
                description="Order by field (prefix with - for descending)",
            ),
        ],
        responses={200: {{ model_name }}ListSerializer(many=True)},
        tags=["{{ app_name_title }}"],
    ),
    create=extend_schema(
        summary="Create {{ model_name_title }}",
        description="Create a new {{ model_name_title }}. Owner is automatically set to authenticated user.",
        request={{ model_name }}CreateSerializer,
        responses={
            201: {{ model_name }}Serializer,
            400: OpenApiResponse(description="Validation error"),
            401: OpenApiResponse(description="Authentication required"),
        },
        tags=["{{ app_name_title }}"],
    ),
    retrieve=extend_schema(
        summary="Get {{ model_name_title }}",
        description="Retrieve a single {{ model_name_title }} by ID.",
        responses={
            200: {{ model_name }}Serializer,
            404: OpenApiResponse(description="Not found"),
        },
        tags=["{{ app_name_title }}"],
    ),
    update=extend_schema(
        summary="Update {{ model_name_title }}",
        description="Update a {{ model_name_title }}. Only owner or staff can update.",
        request={{ model_name }}Serializer,
        responses={
            200: {{ model_name }}Serializer,
            403: OpenApiResponse(description="Permission denied"),
            404: OpenApiResponse(description="Not found"),
        },
        tags=["{{ app_name_title }}"],
    ),
    partial_update=extend_schema(
        summary="Partial Update {{ model_name_title }}",
        description="Partially update a {{ model_name_title }}. Only owner or staff can update.",
        request={{ model_name }}Serializer,
        responses={
            200: {{ model_name }}Serializer,
            403: OpenApiResponse(description="Permission denied"),
            404: OpenApiResponse(description="Not found"),
        },
        tags=["{{ app_name_title }}"],
    ),
    destroy=extend_schema(
        summary="Delete {{ model_name_title }}",
        description="Delete a {{ model_name_title }}. Only owner or staff can delete.",
        responses={
            204: OpenApiResponse(description="Successfully deleted"),
            403: OpenApiResponse(description="Permission denied"),
            404: OpenApiResponse(description="Not found"),
        },
        tags=["{{ app_name_title }}"],
    ),
)
class {{ model_name }}ViewSet(viewsets.ModelViewSet):
    """
    Complete CRUD API for {{ model_name }}.

    Features:
    - List with filtering, search, ordering
    - Create with automatic owner assignment
    - Update/Delete with owner permission
    - Custom actions (archive, publish, duplicate)

    Permissions:
    - List/Retrieve: Public (read-only) or authenticated
    - Create: Authenticated required
    - Update/Delete: Owner or staff only

    Filtering:
        ?status=active          Filter by status
        ?search=keyword         Search in title, description
        ?ordering=-created_at   Order by field

    Pagination:
        Default: 20 items per page
        ?page=2                 Page number
        ?page_size=50           Items per page (max 100)
    """

    queryset = {{ model_name }}.objects.select_related('owner').filter(is_active=True)
    serializer_class = {{ model_name }}Serializer
    {% if auth_required %}
    permission_classes = [IsAuthenticated, IsOwnerOrReadOnly]
    {% else %}
    permission_classes = [IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly]
    {% endif %}

    # Filtering backends
    filter_backends = [
        DjangoFilterBackend,
        filters.SearchFilter,
        filters.OrderingFilter,
    ]
    filterset_fields = ['status', 'is_active', 'owner']
    search_fields = ['title', 'description']
    ordering_fields = ['created_at', 'updated_at', 'title']
    ordering = ['-created_at']

    def get_serializer_class(self):
        """
        Return appropriate serializer based on action.

        - list: Lightweight serializer
        - create: Validation-focused serializer
        - others: Full serializer
        """
        if self.action == 'list':
            return {{ model_name }}ListSerializer
        elif self.action == 'create':
            return {{ model_name }}CreateSerializer
        return {{ model_name }}Serializer

    def get_queryset(self):
        """
        Filter queryset based on user permissions.

        - Staff: All objects
        - Authenticated: Own objects + public
        - Anonymous: Public only
        """
        user = self.request.user
        queryset = super().get_queryset()

        if user.is_staff:
            return queryset
        elif user.is_authenticated:
            # Own objects + public active objects
            return queryset.filter(
                models.Q(owner=user) | models.Q(status='active')
            ).distinct()
        else:
            # Public only
            return queryset.filter(status='active')

    def perform_create(self, serializer):
        """
        Automatically assign owner on create.

        The owner is set to the authenticated user.
        """
        serializer.save(owner=self.request.user)

    @extend_schema(
        summary="Archive {{ model_name_title }}",
        description="Archive a {{ model_name_title }}. Sets status to 'archived' and is_active to False.",
        request=None,
        responses={
            200: OpenApiResponse(
                description="Successfully archived",
                examples=[
                    OpenApiExample(
                        "Success",
                        value={"status": "archived", "id": "uuid-here"}
                    )
                ]
            ),
            403: OpenApiResponse(description="Permission denied"),
            404: OpenApiResponse(description="Not found"),
        },
        tags=["{{ app_name_title }}"],
    )
    @action(detail=True, methods=['post'])
    def archive(self, request, pk=None):
        """
        Archive a {{ model_name }}.

        POST /api/v1/{{ app_name }}/{id}/archive/

        Sets status to 'archived' and is_active to False.
        Only owner or staff can archive.
        """
        obj = self.get_object()
        obj.status = 'archived'
        obj.is_active = False
        obj.save(update_fields=['status', 'is_active', 'updated_at'])
        return Response(
            {'status': 'archived', 'id': str(obj.id)},
            status=status.HTTP_200_OK
        )

    @extend_schema(
        summary="Publish {{ model_name_title }}",
        description="Publish a {{ model_name_title }}. Sets status to 'active'.",
        request=None,
        responses={
            200: OpenApiResponse(
                description="Successfully published",
                examples=[
                    OpenApiExample(
                        "Success",
                        value={"status": "published", "id": "uuid-here"}
                    )
                ]
            ),
            403: OpenApiResponse(description="Permission denied"),
            404: OpenApiResponse(description="Not found"),
        },
        tags=["{{ app_name_title }}"],
    )
    @action(detail=True, methods=['post'])
    def publish(self, request, pk=None):
        """
        Publish a {{ model_name }}.

        POST /api/v1/{{ app_name }}/{id}/publish/

        Sets status to 'active'.
        Only owner or staff can publish.
        """
        obj = self.get_object()
        obj.status = 'active'
        obj.save(update_fields=['status', 'updated_at'])
        return Response(
            {'status': 'published', 'id': str(obj.id)},
            status=status.HTTP_200_OK
        )

    @extend_schema(
        summary="Duplicate {{ model_name_title }}",
        description="Create a copy of {{ model_name_title }} with new UUID and 'draft' status.",
        request=None,
        responses={
            201: {{ model_name }}Serializer,
            403: OpenApiResponse(description="Permission denied"),
            404: OpenApiResponse(description="Not found"),
        },
        tags=["{{ app_name_title }}"],
    )
    @action(detail=True, methods=['post'])
    def duplicate(self, request, pk=None):
        """
        Duplicate a {{ model_name }}.

        POST /api/v1/{{ app_name }}/{id}/duplicate/

        Creates a copy with new UUID and 'draft' status.
        Owner is set to current user.
        """
        obj = self.get_object()
        obj.pk = None  # Creates new object
        obj.id = None
        obj.status = 'draft'
        obj.owner = request.user
        obj.save()
        serializer = self.get_serializer(obj)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    @extend_schema(
        summary="My {{ model_name_title }}s",
        description="Get all {{ model_name_title }}s owned by the authenticated user.",
        responses={200: {{ model_name }}ListSerializer(many=True)},
        tags=["{{ app_name_title }}"],
    )
    @action(detail=False, methods=['get'])
    def my_items(self, request):
        """
        Get current user's {{ model_name }}s.

        GET /api/v1/{{ app_name }}/my_items/

        Returns only objects owned by authenticated user.
        """
        queryset = self.get_queryset().filter(owner=request.user)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

    @extend_schema(
        summary="Bulk Delete {{ model_name_title }}s",
        description="Delete multiple {{ model_name_title }}s by IDs.",
        request={"type": "object", "properties": {"ids": {"type": "array", "items": {"type": "string"}}}},
        responses={
            200: OpenApiResponse(description="Successfully deleted"),
            403: OpenApiResponse(description="Permission denied"),
        },
        tags=["{{ app_name_title }}"],
    )
    @action(detail=False, methods=['post'])
    def bulk_delete(self, request):
        """
        Bulk delete {{ model_name }}s.

        POST /api/v1/{{ app_name }}/bulk_delete/
        Body: {"ids": ["uuid1", "uuid2"]}

        Only deletes objects owned by the user.
        """
        ids = request.data.get('ids', [])
        deleted = {{ model_name }}.objects.filter(
            id__in=ids,
            owner=request.user
        ).delete()
        return Response({
            'deleted': deleted[0],
            'message': f'Deleted {deleted[0]} items'
        })
